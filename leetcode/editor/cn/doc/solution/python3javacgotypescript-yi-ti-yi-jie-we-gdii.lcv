### æ–¹æ³•ä¸€ï¼šé—®é¢˜è½¬æ¢ + æ»‘åŠ¨çª—å£

æˆ‘ä»¬å¯ä»¥è½¬æ¢ä¸ºæ±‚ä»¥ä¸‹ä¸¤ä¸ªé—®é¢˜ï¼š

1. æ±‚æ¯ä¸ªå…ƒéŸ³å­—æ¯è‡³å°‘å‡ºç°ä¸€æ¬¡ï¼Œä¸”è‡³å°‘åŒ…å« $k$ ä¸ªè¾…éŸ³å­—æ¯çš„å­å­—ç¬¦ä¸²çš„æ€»æ•° $\textit{f}(k)$ï¼›
2. æ±‚æ¯ä¸ªå…ƒéŸ³å­—æ¯è‡³å°‘å‡ºç°ä¸€æ¬¡ï¼Œä¸”è‡³å°‘åŒ…å« $k + 1$ ä¸ªè¾…éŸ³å­—æ¯çš„å­å­—ç¬¦ä¸²çš„æ€»æ•° $\textit{f}(k + 1)$ã€‚

é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ $\textit{f}(k) - \textit{f}(k + 1)$ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡ä¸€ä¸ªå‡½æ•° $\textit{f}(k)$ï¼Œç”¨äºç»Ÿè®¡æ¯ä¸ªå…ƒéŸ³å­—æ¯è‡³å°‘å‡ºç°ä¸€æ¬¡ï¼Œä¸”è‡³å°‘åŒ…å« $k$ ä¸ªè¾…éŸ³å­—æ¯çš„å­å­—ç¬¦ä¸²çš„æ€»æ•°ã€‚

æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ $\textit{cnt}$ ç»Ÿè®¡æ¯ä¸ªå…ƒéŸ³å­—æ¯çš„å‡ºç°æ¬¡æ•°ï¼Œç”¨ä¸€ä¸ªå˜é‡ $\textit{ans}$ ç»Ÿè®¡ç­”æ¡ˆï¼Œç”¨ä¸€ä¸ªå˜é‡ $\textit{l}$ è®°å½•æ»‘åŠ¨çª—å£çš„å·¦è¾¹ç•Œï¼Œç”¨ä¸€ä¸ªå˜é‡ $\textit{x}$ è®°å½•å½“å‰çª—å£ä¸­è¾…éŸ³å­—æ¯çš„ä¸ªæ•°ã€‚

éå†å­—ç¬¦ä¸²ï¼Œå¦‚æœå½“å‰å­—ç¬¦æ˜¯å…ƒéŸ³å­—æ¯ï¼Œåˆ™å°†å…¶åŠ å…¥å“ˆå¸Œè¡¨ $\textit{cnt}$ ä¸­ï¼Œå¦åˆ™å°† $\textit{x}$ åŠ ä¸€ã€‚å¦‚æœæ­¤æ—¶ $\textit{x} \ge k$ ä¸”å“ˆå¸Œè¡¨ $\textit{cnt}$ çš„å¤§å°ä¸º $5$ï¼Œè¯´æ˜å½“å‰çª—å£æ»¡è¶³æ¡ä»¶ï¼Œæˆ‘ä»¬å¾ªç¯ç§»åŠ¨å·¦è¾¹ç•Œï¼Œç›´åˆ°çª—å£ä¸æ»¡è¶³æ¡ä»¶ã€‚æ­¤æ—¶ï¼Œä»¥å³è¾¹ç•Œ $\textit{r}$ ä¸ºç»“å°¾ã€ä¸”å·¦è¾¹ç•Œåœ¨ $[0,.. \textit{l} - 1]$ èŒƒå›´å†…çš„å­å­—ç¬¦ä¸²éƒ½æ»¡è¶³æ¡ä»¶ï¼Œä¸€å…±æœ‰ $\textit{l}$ ä¸ªã€‚æˆ‘ä»¬å°† $\textit{l}$ åŠ åˆ°ç­”æ¡ˆä¸­ã€‚ç»§ç»­éå†å­—ç¬¦ä¸²ï¼Œç›´åˆ°éå†ç»“æŸï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº† $\textit{f}(k)$ã€‚

æœ€åï¼Œæˆ‘ä»¬è¿”å› $\textit{f}(k) - \textit{f}(k + 1)$ã€‚

* [sol1-Python3]

```python
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        def f(k: int) -> int:
            cnt = Counter()
            ans = l = x = 0
            for c in word:
                if c in "aeiou":
                    cnt[c] += 1
                else:
                    x += 1
                while x >= k and len(cnt) == 5:
                    d = word[l]
                    if d in "aeiou":
                        cnt[d] -= 1
                        if cnt[d] == 0:
                            cnt.pop(d)
                    else:
                        x -= 1
                    l += 1
                ans += l
            return ans

        return f(k) - f(k + 1)
```

* [sol1-Java]

```java
class Solution {
    public int countOfSubstrings(String word, int k) {
        return f(word, k) - f(word, k + 1);
    }

    private int f(String word, int k) {
        int ans = 0;
        int l = 0, x = 0;
        Map<Character, Integer> cnt = new HashMap<>(5);
        for (char c : word.toCharArray()) {
            if (vowel(c)) {
                cnt.merge(c, 1, Integer::sum);
            } else {
                ++x;
            }
            while (x >= k && cnt.size() == 5) {
                char d = word.charAt(l++);
                if (vowel(d)) {
                    if (cnt.merge(d, -1, Integer::sum) == 0) {
                        cnt.remove(d);
                    }
                } else {
                    --x;
                }
            }
            ans += l;
        }
        return ans;
    }

    private boolean vowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int countOfSubstrings(string word, int k) {
        auto f = [&](int k) -> int {
            int ans = 0;
            int l = 0, x = 0;
            unordered_map<char, int> cnt;
            auto vowel = [&](char c) -> bool {
                return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
            };
            for (char c : word) {
                if (vowel(c)) {
                    cnt[c]++;
                } else {
                    ++x;
                }
                while (x >= k && cnt.size() == 5) {
                    char d = word[l++];
                    if (vowel(d)) {
                        if (--cnt[d] == 0) {
                            cnt.erase(d);
                        }
                    } else {
                        --x;
                    }
                }
                ans += l;
            }
            return ans;
        };

        return f(k) - f(k + 1);
    }
};
```

* [sol1-Go]

```go
func countOfSubstrings(word string, k int) int {
	f := func(k int) int {
		var ans int = 0
		l, x := 0, 0
		cnt := make(map[rune]int)
		vowel := func(c rune) bool {
			return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
		}
		for _, c := range word {
			if vowel(c) {
				cnt[c]++
			} else {
				x++
			}
			for x >= k && len(cnt) == 5 {
				d := rune(word[l])
				l++
				if vowel(d) {
					cnt[d]--
					if cnt[d] == 0 {
						delete(cnt, d)
					}
				} else {
					x--
				}
			}
			ans += l
		}
		return ans
	}

	return f(k) - f(k+1)
}
```

* [sol1-TypeScript]

```ts
function countOfSubstrings(word: string, k: number): number {
    const f = (k: number): number => {
        let ans = 0;
        let l = 0,
            x = 0;
        const cnt = new Map<string, number>();

        const vowel = (c: string): boolean => {
            return c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u';
        };

        for (const c of word) {
            if (vowel(c)) {
                cnt.set(c, (cnt.get(c) || 0) + 1);
            } else {
                x++;
            }

            while (x >= k && cnt.size === 5) {
                const d = word[l++];
                if (vowel(d)) {
                    cnt.set(d, cnt.get(d)! - 1);
                    if (cnt.get(d) === 0) {
                        cnt.delete(d);
                    }
                } else {
                    x--;
                }
            }
            ans += l;
        }

        return ans;
    };

    return f(k) - f(k + 1);
}
```

* [sol1-Rust]

```rust
impl Solution {
    pub fn count_of_substrings(word: String, k: i32) -> i32 {
        fn f(word: &Vec<char>, k: i32) -> i32 {
            let mut ans = 0;
            let mut l = 0;
            let mut x = 0;
            let mut cnt = std::collections::HashMap::new();

            let is_vowel = |c: char| matches!(c, 'a' | 'e' | 'i' | 'o' | 'u');

            for (r, &c) in word.iter().enumerate() {
                if is_vowel(c) {
                    *cnt.entry(c).or_insert(0) += 1;
                } else {
                    x += 1;
                }

                while x >= k && cnt.len() == 5 {
                    let d = word[l];
                    l += 1;
                    if is_vowel(d) {
                        let count = cnt.entry(d).or_insert(0);
                        *count -= 1;
                        if *count == 0 {
                            cnt.remove(&d);
                        }
                    } else {
                        x -= 1;
                    }
                }
                ans += l as i32;
            }
            ans
        }

        let chars: Vec<char> = word.chars().collect();
        f(&chars, k) - f(&chars, k + 1)
    }
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯å­—ç¬¦ä¸² $\textit{word}$ çš„é•¿åº¦ã€‚ç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚

----

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
