### 解题思路：前缀异或和、

#### 仔细分析题目意思就可知道：任何满足题目要求的子数组必须满足以下条件：子数组中每个二进制数位上出现的1的个数必须为偶数个。

##### 例如：[3,1,2]转化为二进制则为[011,001,010],其中第一位1的个数为2，第二位1的个数为2，第三位为0，所以由此可以想到异或操作，因为异或操作可以将1进行消除（1与1异或等于0），也就是说满足题目要求的子数组的异或和等于0

##### 此时，我们已经将题目转化为：求出满足异或和等于0的子数组的个数，但是这个时候暴解时间复杂度为n的3次方，可能超出时间限制

##### 我们需要了解异或的如下两条性质：

> 任何数与本身异或都等于0
> 任何数与0异或都等于其本身

也就是说

> a4 ^ a5 = (a1 ^ a2 ^ a3 ^ a4 ^ a5 ) ^ (a1 ^ a2 ^ a3)

那么当

> a1 ^ a2 ^ a3 ^ a4 ^ a5  = a1 ^ a2 ^ a3时，a4 ^ a5 = 0

知道了上述性质，我们就可以根据前面的异或和找到以s[i]结尾的异或和等于0的子数组，只需要找到前面有哪些子数组异或和等于从零到i的异或和

代码如下：

* []

```c++
class Solution {
public:
    long long beautifulSubarrays(vector<int>& nums) {
        int s = 0;
        // set<int> dict;
        unordered_map<int,int> dict;    //该字典的first为异或和，second为异或和出现的次数
        dict[0] = 1;
        long long count = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            s = s ^ nums[i];
            if(dict.count(s))
            {
                count += dict[s];
                dict[s]++;
            }
            else
                dict[s] = 1;
        }
        
        return count;
    }
};
```

