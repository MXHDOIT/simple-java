### æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ + åŒæŒ‡é’ˆ

å¯¹äºä¸€ä¸ªä½ç½®ï¼Œè¶Šæ—©åˆ‡ï¼Œæ‰€éœ€è¦åˆ‡çš„æ¬¡æ•°è¶Šå°‘ï¼Œå› æ­¤ï¼Œæ˜¾ç„¶æ˜¯å¼€é”€è¶Šå¤§çš„ä½ç½®è¶Šæ—©åˆ‡ã€‚

æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ•°ç»„ $\textit{horizontalCut}$ å’Œ $\textit{verticalCut}$ æŒ‰ç…§ä»å¤§åˆ°å°çš„é¡ºåºæ’åºï¼Œç„¶åä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ $i$ å’Œ $j$ åˆ†åˆ«æŒ‡å‘ $\textit{horizontalCut}$ å’Œ $\textit{verticalCut}$ çš„å¼€é”€ï¼Œæ¯æ¬¡é€‰æ‹©å¼€é”€è¾ƒå¤§çš„ä½ç½®è¿›è¡Œåˆ‡å‰²ï¼ŒåŒæ—¶æ›´æ–°å¯¹åº”çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚

æ¯æ¬¡åœ¨æ°´å¹³æ–¹å‘ä¸Šåˆ‡å‰²æ—¶ï¼Œå¦‚æœæ­¤å‰åˆ—æ•°ä¸º $v$ï¼Œé‚£ä¹ˆæ­¤æ¬¡çš„å¼€é”€ä¸º $\textit{horizontalCut}[i] \times v$ï¼Œç„¶åè¡Œæ•° $h$ åŠ ä¸€ï¼›åŒç†ï¼Œæ¯æ¬¡åœ¨å‚ç›´æ–¹å‘ä¸Šåˆ‡å‰²æ—¶ï¼Œå¦‚æœæ­¤å‰è¡Œæ•°ä¸º $h$ï¼Œé‚£ä¹ˆæ­¤æ¬¡çš„å¼€é”€ä¸º $\textit{verticalCut}[j] \times h$ï¼Œç„¶ååˆ—æ•° $v$ åŠ ä¸€ã€‚

æœ€åï¼Œå½“ $i$ å’Œ $j$ éƒ½åˆ°è¾¾æœ«å°¾æ—¶ï¼Œè¿”å›æ€»å¼€é”€å³å¯ã€‚

* [sol1-Python3]

```python
class Solution:
    def minimumCost(
        self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]
    ) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        ans = i = j = 0
        h = v = 1
        while i < m - 1 or j < n - 1:
            if j == n - 1 or (i < m - 1 and horizontalCut[i] > verticalCut[j]):
                ans += horizontalCut[i] * v
                h, i = h + 1, i + 1
            else:
                ans += verticalCut[j] * h
                v, j = v + 1, j + 1
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {
        Arrays.sort(horizontalCut);
        Arrays.sort(verticalCut);
        int ans = 0;
        int i = m - 2, j = n - 2;
        int h = 1, v = 1;
        while (i >= 0 || j >= 0) {
            if (j < 0 || (i >= 0 && horizontalCut[i] > verticalCut[j])) {
                ans += horizontalCut[i--] * v;
                ++h;
            } else {
                ans += verticalCut[j--] * h;
                ++v;
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
        sort(horizontalCut.rbegin(), horizontalCut.rend());
        sort(verticalCut.rbegin(), verticalCut.rend());
        int ans = 0;
        int i = 0, j = 0;
        int h = 1, v = 1;
        while (i < m - 1 || j < n - 1) {
            if (j == n - 1 || (i < m - 1 && horizontalCut[i] > verticalCut[j])) {
                ans += horizontalCut[i++] * v;
                h++;
            } else {
                ans += verticalCut[j++] * h;
                v++;
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func minimumCost(m int, n int, horizontalCut []int, verticalCut []int) (ans int) {
	sort.Sort(sort.Reverse(sort.IntSlice(horizontalCut)))
	sort.Sort(sort.Reverse(sort.IntSlice(verticalCut)))
	i, j := 0, 0
	h, v := 1, 1
	for i < m-1 || j < n-1 {
		if j == n-1 || (i < m-1 && horizontalCut[i] > verticalCut[j]) {
			ans += horizontalCut[i] * v
			h++
			i++
		} else {
			ans += verticalCut[j] * h
			v++
			j++
		}
	}
	return
}
```

* [sol1-TypeScript]

```ts
function minimumCost(m: number, n: number, horizontalCut: number[], verticalCut: number[]): number {
    horizontalCut.sort((a, b) => b - a);
    verticalCut.sort((a, b) => b - a);
    let ans = 0;
    let [i, j] = [0, 0];
    let [h, v] = [1, 1];
    while (i < m - 1 || j < n - 1) {
        if (j === n - 1 || (i < m - 1 && horizontalCut[i] > verticalCut[j])) {
            ans += horizontalCut[i] * v;
            h++;
            i++;
        } else {
            ans += verticalCut[j] * h;
            v++;
            j++;
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(m \times \log m + n \times \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(\log m + \log n)$ã€‚å…¶ä¸­ $m$ å’Œ $n$ åˆ†åˆ«ä¸º $\textit{horizontalCut}$ å’Œ $\textit{verticalCut}$ çš„é•¿åº¦ã€‚

----

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
